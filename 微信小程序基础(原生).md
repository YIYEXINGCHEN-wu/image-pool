## 基本结构

主要的原生代码所在页面就是pages文件夹下，每一个页面，标配四种文件，有点类似于一个Vue组件中含有的三部分(比如\<template>、\<script>、\<style>标签)，在微信小程序页面，就是index文件夹下含有index.js，index.json(局部配置，而app.json为全局配置)，index.wxml(类似于html的结构的布局页面)，index.wxss(类似于css样式文件)。



## WXML基础

```html
# 类似于Div的标签，独占一行
<view></view>
# 类似于span标签
<text></text>
# 类似于img标签
<image src="" mode=""></image>
# 类似于a标签，但又不同，它不会刷新
<navigator url="/pages/index/index">
 // ... 这里可以有其它元素 
</navigator>
```

**条件渲染**

```html
<view>
  <view wx:if="{{ showFlag == 0 }}">姓名：{{ students[0].name }} - 年龄：{{ students[0].age }}</view>
  <view wx:elif="{{ showFlag==1 }}">姓名：{{ students[1].name }} - 年龄：{{ students[1].age }}</view>
  <view wx:elif="{{ showFlag==2 }}">姓名：{{ students[2].name }} - 年龄：{{ students[2].age }}</view>
  <view wx:elif="{{ showFlag==3 }}">姓名：{{ students[3].name }} - 年龄：{{ students[3].age }}</view>
  <view wx:else>
    无效
  </view>
</view>
<view>
   <!-- 可以只使用wx:for属性，但是如果再次嵌套，则需要避免item冲突 -->
  <view wx:for="{{ students }}" wx:for-item="item" wx:for-index="index" wx:key="index">
    序号：{{ index }}，学生姓名：{{ item.name }}，学生年龄：{{ item.age }}
  </view>
</view>
```

**生命周期**

```javascript
// pages/demo/demo.ts
Page({
  /**
   * 页面的初始数据
   */
  data: {
    showFlag: 0,
    students: [
      {
        name: "张三",
        age: 17,
      },
      {
        name: "李四",
        age: 18
      },
      {
        name: "王五",
        age: 19
      },
      {
        name: "赵六",
        age: 20
      }
    ]
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad() {
    this.setData({
      showFlag: 2,
    })
  },
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady() {
      // 页面内容渲染完毕
  },
  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {
      // 从后台切换回来时自动调用
  },
  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide() {
	// 切换到后台时自动调用
  },
  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload() {
	// 切换页面时自动调用
  },
  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh() {
       // 需要用户开启当前页面的json配置文件
  },
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom() {
  },
  /**
   * 用户点击右上角分享
   */
  onShareAppMessage() {
  }
})
```

**事件**

```html
// 下面如果点击最里层的view则只会触发最里层的和中间层事件
// 如果触碰中间层，则只会触发中间层事件
<view class="outer" bind:tap="tapOuter">
    这个是最外层的view
    <view class="middle" catch:tap="tapMiddle">
        这个是中层view
        <view class="inner" bind:tap="tapInner">
            这个是最里层view
        </view>
    </view>
</view>
```

```typescript
tapInner() {
    console.log("最里层已经接触到")
},
tapMiddle() {
     console.log("中间层已经接触到")
 },
tapOuter() {
    console.log("最外层已经接触到")
},
```







**样式控制**

 ```html
 <view style="background-color: {{ 'skyblue' }}" class="{{ 'test' }}"></view>
 ```

**模块**

WXS不支持ES6语法，所以const、let等都无法使用。

创建wxs文件夹，并创建相应wxs文件：

```javascript
// wxs文件是不支持ES6语法的
var num = 0;
function showInfo() {
    console.log("你好，世界！");
}
function showNum() {
    console.log(num); // 这个值将是最新的值
}
function incrementNum() {
    num++; // 这里虽然已经改变，但是页面不会重新渲染
    console.log(num);
}

module.exports = {
    num: num,
    showInfo: showInfo,
    incrementNum: incrementNum,
    showNum: showNum
}
```

在WXML文件中导入进行使用：

```html
<wxs src="../../wxs/test.wxs" module="info"></wxs>
<view>
    {{ info.num }}
</view>
<view >
    {{ info.showInfo() }}
</view>
<text bind:tap="{{ info.incrementNum }}">增加wxs中的变量值</text>
<text bind:tap="{{ info.showNum }}">显示变量值</text>
```



**组件**

实现双向通信，父传子和子传父过程，过程同React父子通信类似。

首先在根路径创建一个components文件夹，在其下创建页面组件，即四个标准文件：

```json
// /componets/test/test.json
{
    "usingComponents": {}
}
```

```typescript
// /componets/test/test.ts
Component({
    properties: {
        student: {
            type: Object,
            value: {
                name: "默认名称",
                age: 0
            }
        }
    },
    data: {
        info: "这是子组件的信息"
    },
    methods: {
        emitInfo() {
            // 自定义子组件事件名称，并调用this.triggerEvent()方法
            this.triggerEvent("emit", this.data.info);
        }
    }
})
```

```html
// /componets/test/test.wxml
<view>
    <view>
        我是子组件，以下是父组件传过来的信息
    </view> 
    <view>
        {{ student.name }}
    </view>
    <view>
        {{ student.age }}
    </view>
    <view bind:tap="emitInfo">
        触摸当前节点发送消息到父组件中
    </view>
</view>
```

```css
// /componets/test/test.wxss
```

然后选择一个需要使用该子组件的文件：

```typescript
// /pages/test1/test1.ts
/**
* 页面的初始数据
*/
data: {
    studentInfo: {
        name: "张三",
            age: 20
    },
        info: "这里需要通过子传父组件内容"
},
changeInfo(info: any) {
     // console.log(info) 子组件传递过来的数据是在detail中
     this.setData({
         info: info.detail
     })
 },
```

```json
// /pages/test1/test1.json
{
    "usingComponents": {
        "Test": "../../components/test/test"
    }
}
```



```html
// /pages/test1/test1.wxml

<!-- 以下是父传子过程 以及 父传子过程 -->
<Test student="{{ studentInfo }}" bind:emit="changeInfo"></Test>
<view>
    这里展示子传父的信息：{{ info }}
</view>
```

**模板**

新建templates文件夹，然后在miniprogram下创建templates文件夹：
```html
<!-- 文件地址和名称: templates/test-template/test-template.wxml -->
<template name="mine-template">
    <view class="main">这是个模板，测试</view>
</template>
```
```scss
.main {
	color: skyblue;
}
```
使用：
```html
<import src="../../templates/test-template/test-template" />
<view>
	<template is="mine-template">
</view>
```









**UniCould来存储静态资源**









